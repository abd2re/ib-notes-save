---
tags: [EE] 
---
Created: 2022-12-12

Let's begin by explaining the Minimax search algorithm because it is the most straight-forward from the two algorithms in this experiment. The Minimax Search Algorithm is a graph decision algorithm used, in this case, to offer move candidates for a game-playing Connect Four algorithm. It's name comes from its goal to _minimize_ the score of its opponent while _maximizing_ our own score at every move made \cite{daitzman} because our opponent will constantly be trying to minimize our chances and we will be constantly trying to maximizing our chance which draws back to the zero-sum nature of Connect 4 in which someone's gain is always the opponent's loss and vice versa. Minimax can be represented with a game tree where every node represent the value of a game state starting from the root node (Level 0) which is the initial game state, branching out into his "child" nodes (Level 1) that will further branch out into "grandchild" (Level 2) nodes and so on until reaching a terminal state \cite{tds} (view figX). Knowing a standard Connect 4 game can have up 4.5 trillion combinations, branching out all nodes in a Minimax search algorithm would be an impossible task for modern machines to compute in a reasonable amount of time (view figX). Because of that, we have to limit our level of search depth. In theory, the deeper the depth of search is, the more knowledge a Minimax search algorithm has to find the best move, with that information we need to have a depth of search that is not too big that it will take too much time to compute but not too small that the search algorithm has very small information.

In the figure above, we can see that the minimizing nodes have taken the smallest values out of their children, 3 and 2 respectively, and that the maximizing node at the top which is also the root node took the biggest value out of his 2 children, in this case he picked 3. We see that the Minimax search tree is a  recursive algorithm in that the maximizing players calls the minimizing player, and that the minimizing player calls the maximizing player, this presumes that both players will always play the most advantageous move. The conditions we have to break out of the recursive loop is that if we reach a node where someone has won, or both players have drawn, or have reached a pre-determined depth limit \cite{tds}. 

The time complexity of a Minimax search algorithm is $\mathcal{O}(b^m)$ where $b$ is the branching factor or number of legal moves at each point and $m$ the maximum depth of the tree. This time complexity is moderate for a classical 6x7 grid, but as the size of the grid becomes larger, the effects of the time complexity becomes clearer as the maximum depth of the increasing grid sizes are bigger and the branching factor gets bigger too. To alleviate this problem, we will need to significantly reduce the number of nodes to search and fortunately there is an optimization of the Minimax search algorithm that is called Alpha–Beta pruning that we will see in the next subsection.